#!/usr/bin/env python3
"""
Memory‑safe video assembler for scenic kitesurf montages.

This build forces **live progress output** on Windows shells:
- Prints during scan now use `flush=True` so lines appear immediately.
- Writing still uses MoviePy's built‑in progress bar (logger='bar').
- Use `--logger verbose` for frame‑level logs if you want more chatter.

Other goodies:
- Default output 1080p, Pillow 10 fix, UHD skip unless `--include-uhd`, scan limiter, selftest.
"""
from __future__ import annotations
import argparse
import glob
import os
import pathlib
import random
import tempfile
import time

# --- Pillow 10+ compatibility: provide deprecated resample constants for MoviePy ---
try:
    from PIL import Image as _PIL_Image
    if not hasattr(_PIL_Image, "ANTIALIAS"):
        from PIL import Image
        Image.ANTIALIAS = Image.Resampling.LANCZOS  # type: ignore[attr-defined]
        Image.BICUBIC = Image.Resampling.BICUBIC    # type: ignore[attr-defined]
        Image.BILINEAR = Image.Resampling.BILINEAR  # type: ignore[attr-defined]
except Exception:
    pass

from moviepy.editor import VideoFileClip, AudioFileClip, concatenate_videoclips, ColorClip


def latest_broll_dir(root: pathlib.Path) -> pathlib.Path | None:
    candidates = [p for p in root.glob("*") if p.is_dir()]
    if not candidates:
        return None
    return max(candidates, key=lambda p: p.name)


def is_uhd_filename(name: str) -> bool:
    n = name.lower()
    return any(tok in n for tok in ["3840_2160", "4096_", "uhd"])  # simple heuristic


def build_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Assemble a scenic montage from downloaded b-roll")
    p.add_argument("--broll-dir", type=pathlib.Path, default=None,
                   help="Folder with mp4 clips (default: latest under content/assets/broll)")
    p.add_argument("--output", type=pathlib.Path, default=pathlib.Path("content/uploads/scenic_montage_001.mp4"))
    p.add_argument("--target-seconds", type=int, default=90, help="Target montage length in seconds")
    p.add_argument("--min-clip-seconds", type=float, default=5.0)
    p.add_argument("--max-clip-seconds", type=float, default=8.0)
    p.add_argument("--max-clips", type=int, default=20, help="Upper bound on clips to concatenate")
    p.add_argument("--max-height", type=int, default=1080, help="Resize each subclip to this height (reduces memory)")
    p.add_argument("--fps", type=int, default=30, help="Output frames per second")
    p.add_argument("--threads", type=int, default=2, help="FFmpeg threads for writing")
    p.add_argument("--music", type=pathlib.Path, default=pathlib.Path("content/assets/music"), help="Folder with .mp3 (optional)")
    p.add_argument("--logger", choices=["bar", "verbose", "none"], default="bar", help="Progress logger: bar|verbose|none")
    p.add_argument("--scan-limit", type=int, default=40, help="Max number of files to probe before we have enough clips")
    g = p.add_mutually_exclusive_group()
    g.add_argument("--skip-uhd", dest="skip_uhd", action="store_true", help="Skip 4K/uhd files by filename (default)")
    g.add_argument("--include-uhd", dest="skip_uhd", action="store_false", help="Allow 4K/uhd files in the scan")
    p.set_defaults(skip_uhd=True)
    p.add_argument("--selftest", action="store_true", help="Generate small synthetic clips and run pipeline")
    return p.parse_args()


def safe_subclip(path: str, args: argparse.Namespace):
    clip = None
    try:
        clip = VideoFileClip(path, audio=False)
        dur = float(getattr(clip, "duration", 0) or 0)
        if dur < args.min_clip_seconds + 0.5:
            return None
        start = random.uniform(0, max(0.0, dur - args.max_clip_seconds - 0.1))
        end = min(dur, start + random.uniform(args.min_clip_seconds, args.max_clip_seconds))
        sub = clip.subclip(start, end)
        if args.max_height and getattr(sub, "h", 0) > args.max_height:
            sub = sub.resize(height=args.max_height)
        return sub
    except Exception as e:
        print("  ↳ Skip:", os.path.basename(path), "=>", e, flush=True)
        try:
            if clip is not None:
                clip.reader.close()
                if getattr(clip, "audio", None):
                    clip.audio.reader.close_proc()
        except Exception:
            pass
        return None


def write_video(selected, args: argparse.Namespace):
    total_dur = sum(float(c.duration or 0) for c in selected)
    print(f"Concatenating {len(selected)} clips (~{total_dur:.1f}s)…", flush=True)
    t0 = time.time()
    video = concatenate_videoclips(selected, method="compose")
    print(f"Concatenated in {time.time()-t0:.1f}s. Writing to {args.output} …", flush=True)

    # Optional music
    music_files = []
    try:
        if args.music and args.music.exists():
            music_files = [p for p in args.music.glob("*.mp3")]
    except Exception:
        music_files = []
    if music_files:
        try:
            music = AudioFileClip(str(random.choice(music_files))).volumex(0.15)
            video = video.set_audio(music.set_duration(video.duration))
        except Exception as e:
            print("Music load error:", e, flush=True)

    args.output.parent.mkdir(parents=True, exist_ok=True)
    logger = None if args.logger == "none" else args.logger  # 'bar' or 'verbose' prints a progress bar/logs
    video.write_videofile(
        str(args.output),
        codec="libx264",
        audio_codec="aac",
        fps=args.fps,
        threads=max(1, int(args.threads)),
        preset="veryfast",
        remove_temp=True,
        ffmpeg_params=["-movflags", "faststart"],
        logger=logger,
    )
    print("Saved", args.output, flush=True)


def selftest_run():
    tmpdir = pathlib.Path(tempfile.mkdtemp(prefix="assemble_selftest_"))
    try:
        colors = [(255, 80, 80), (80, 255, 80), (80, 80, 255)]
        srcs = []
        for i, col in enumerate(colors, 1):
            clip = ColorClip(size=(640, 360), color=col, duration=2).set_fps(24)
            p = tmpdir / f"test_{i}.mp4"
            clip.write_videofile(str(p), codec="libx264", audio=False, fps=24, preset="ultrafast", threads=1, logger=None)
            srcs.append(str(p))
            clip.close()
        class DummyArgs:
            min_clip_seconds = 1.0
            max_clip_seconds = 1.5
            max_height = 480
            fps = 24
            threads = 1
            music = pathlib.Path("./no_music")
            output = tmpdir / "out.mp4"
            logger = "bar"
        args = DummyArgs()
        selected = []
        for s in srcs:
            sc = safe_subclip(s, args)
            if sc:
                selected.append(sc)
        if not selected:
            raise SystemExit("selftest: no subclips")
        write_video(selected, args)
        for c in selected:
            c.close()
        print("[selftest] OK =>", args.output)
    finally:
        pass


def main():
    args = build_args()

    if args.selftest:
        selftest_run()
        return

    broll_root = pathlib.Path("content/assets/broll")
    broll_dir = args.broll_dir or latest_broll_dir(broll_root)
    if not broll_dir or not broll_dir.exists():
        raise SystemExit("No b-roll directory found. Run scripts/fetch_assets.py first.")

    mp4s = sorted(glob.glob(str(broll_dir / "*.mp4")))
    if not mp4s:
        raise SystemExit(f"No mp4 files found in {broll_dir}")

    # Filter out UHD unless overridden
    filtered = [p for p in mp4s if (not args.skip_uhd) or (not is_uhd_filename(os.path.basename(p)))]
    if not filtered:
        filtered = mp4s  # fall back if our heuristic removed everything

    random.shuffle(filtered)

    print(f"Scanning up to {min(args.scan_limit, len(filtered))} of {len(filtered)} files in {broll_dir} …", flush=True)

    selected = []
    total = 0.0
    scanned = 0
    for path in filtered:
        if scanned >= args.scan_limit:
            print("Reached scan limit; proceeding with what we have…", flush=True)
            break
        if len(selected) >= args.max_clips or total >= args.target_seconds:
            break
        scanned += 1
        print(f"[{scanned}/{min(args.scan_limit, len(filtered))}] Probing: {os.path.basename(path)}", flush=True)
        sub = safe_subclip(path, args)
        if sub is None:
            continue
        selected.append(sub)
        total += float(sub.duration or 0)

    if not selected:
        raise SystemExit("No suitable clips to assemble.")

    try:
        write_video(selected, args)
    finally:
        # Close all subclips to free memory
        for c in selected:
            try:
                c.close()
            except Exception:
                pass


if __name__ == "__main__":
    main()
